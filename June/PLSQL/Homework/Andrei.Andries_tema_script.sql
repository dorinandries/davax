-- Am creat o copie a tabelului EMPLOYEES din cauză că după câteva modificări ale salariului va apărea eroare din cauza dimensiunii coloanei salary;
-- moment în care se va reinițializa tabelul EMPLOYEES2 

DROP TABLE employees2;

CREATE TABLE employees2
    AS
        SELECT
            *
        FROM
            employees;

-- Am creat un package separat pentru a determina tipul metodei din package ( FUNCTION sau PROCEDURE )
CREATE OR REPLACE PACKAGE object_type AS
    FUNCTION get_object_type (
        p_name IN VARCHAR2
    ) RETURN VARCHAR2;

END object_type;
/

CREATE OR REPLACE PACKAGE BODY object_type AS

    FUNCTION get_object_type (
        p_name IN VARCHAR2
    ) RETURN VARCHAR2 IS
        v_type VARCHAR2(20);
        v_pkg  VARCHAR2(30);
        v_sub  VARCHAR2(30);
    BEGIN
    -- Tratarea cazului în care p_name primește un string sub forma PACKAGE.MODULE și se realizează o separare
        IF instr(p_name, '.') > 0 THEN 
            v_pkg := substr(p_name,
                            1,
                            instr(p_name, '.') - 1);

            v_sub := substr(p_name,
                            instr(p_name, '.') + 1);
            BEGIN
                SELECT
                    type AS subprogram_type
                INTO v_type
                FROM
                    user_identifiers
                WHERE
                        object_type = 'PACKAGE'
                    AND object_name = upper(v_pkg)
                    AND type IN ( 'FUNCTION', 'PROCEDURE' )
                    AND name = upper(v_sub)
                ORDER BY
                    name;
            EXCEPTION
                WHEN no_data_found THEN
                    v_type := 'UNKNOWN';
            END;

        ELSE
            BEGIN
                SELECT
                    object_type
                INTO v_type
                FROM
                    user_objects
                WHERE
                        object_name = upper(p_name)
                    AND object_type IN ( 'PACKAGE', 'FUNCTION', 'PROCEDURE' )
                    AND ROWNUM = 1;

            EXCEPTION
                WHEN no_data_found THEN
                    v_type := 'UNKNOWN';
            END;
        END IF;

        RETURN v_type;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'UNKNOWN';
    END get_object_type;

END object_type;
/


-- DROP TABLE debug_log;

CREATE TABLE debug_log (
    log_id          NUMBER
        GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
    log_time        TIMESTAMP DEFAULT systimestamp,
    module_name     VARCHAR2(100),
    line_no         NUMBER,
    -- log_level are scopul de a înregistra tipul de log ( debug, warning, info, error )
    log_level       VARCHAR2(10),
    log_message     VARCHAR2(4000),
    session_id      VARCHAR2(50) DEFAULT sys_context('USERENV', 'SESSIONID'),
    -- Am adăugat coloana user_session_id pentru a afisa si userul care a efectuat operațiunile
    user_session_id VARCHAR2(50) DEFAULT sys_context('USERENV', 'SESSION_USER')
);

CREATE OR REPLACE PACKAGE debug_utils AS
    -- Variabile globale
    g_debug_mode BOOLEAN := FALSE;
    TYPE t_log_levels IS
        VARRAY(4) OF VARCHAR2(10);
    g_log_levels t_log_levels := t_log_levels('DEBUG', 'INFO', 'WARNING', 'ERROR');

  -- Activează/dezactivează modul debug
    PROCEDURE enable_debug;

    PROCEDURE disable_debug;

  -- Proceduri de log
    PROCEDURE log_msg (
        p_module_name VARCHAR2,
        p_unit_name   VARCHAR2,
        p_message     VARCHAR2,
        p_line_no     PLS_INTEGER,
        p_log_level   VARCHAR2
    );

    PROCEDURE log_variable (
        p_module_name VARCHAR2,
        p_unit_name   VARCHAR2,
        p_name        VARCHAR2,
        p_value       VARCHAR2,
        p_line_no     PLS_INTEGER,
        p_log_level   VARCHAR2
    );

    PROCEDURE log_error (
        p_module_name VARCHAR2,
        p_unit_name   VARCHAR2,
        p_err         VARCHAR2,
        p_line_no     PLS_INTEGER,
        p_log_level   VARCHAR2
    );

END debug_utils;
/


-- Body-ul package-ului debug_utils
CREATE OR REPLACE PACKAGE BODY debug_utils IS

  -- Enable / Disable debug
    PROCEDURE enable_debug IS
    BEGIN
        g_debug_mode := TRUE;
    END;

    PROCEDURE disable_debug IS
    BEGIN
        g_debug_mode := FALSE;
    END;

  -- Inserare generică de log
    PROCEDURE write_log (
        p_module_name VARCHAR2,
        p_unit_name   VARCHAR2,
        p_msg         VARCHAR2,
        p_line_no     PLS_INTEGER,
        p_log_level   VARCHAR2
    ) IS
        PRAGMA autonomous_transaction;
      -- Creez o sesiune separată de tranzacții pentru inserarea in tabelul debug_log astfel că dacă va fi necesar un rollback pentru employees
      -- acel rollback nu va afecta tranzacția logurilor

    BEGIN
     
      -- Construim și executăm INSERT-ul având 3 case-uri de mesaj ce va fi inserat în coloana module_name din debug_utils
        INSERT INTO debug_log (
            module_name,
            line_no,
            log_message,
            log_level
        ) VALUES (
            CASE
                WHEN upper(p_unit_name) = upper(p_module_name)                     THEN
                    'Stored '
                    || object_type.get_object_type(p_unit_name)
                    || ': '
                    || p_unit_name
                WHEN upper(object_type.get_object_type(p_unit_name)) = 'FUNCTION'  THEN
                    '[Package] --> '
                    || p_module_name
                    || '    [Function] --> '
                    || substr(p_unit_name,
                              instr(p_unit_name, '.') + 1)
                WHEN upper(object_type.get_object_type(p_unit_name)) = 'PROCEDURE' THEN
                    '[Package] --> '
                    || p_module_name
                    || '    [PROCEDURE] --> '
                    || substr(p_unit_name,
                              instr(p_unit_name, '.') + 1)
                ELSE
                    'No package; No procedure; No function. Check anonymous PL/SQL blocks.'
            END,
            p_line_no,
            p_msg,
            p_log_level );

        COMMIT;  -- commit în tranzacție autonomă
    END write_log;

  -- Log de mesaje
    PROCEDURE log_msg (
        p_module_name VARCHAR2,
        p_unit_name   VARCHAR2,
        p_message     VARCHAR2,
        p_line_no     PLS_INTEGER,
        p_log_level   VARCHAR2
    ) IS
    BEGIN
        IF g_debug_mode THEN
            write_log(p_module_name, p_unit_name, p_message, p_line_no, p_log_level);
        END IF;
    END;

  -- Log de variabile
    PROCEDURE log_variable (
        p_module_name VARCHAR2,
        p_unit_name   VARCHAR2,
        p_name        VARCHAR2,
        p_value       VARCHAR2,
        p_line_no     PLS_INTEGER,
        p_log_level   VARCHAR2
    ) IS
    BEGIN
        IF g_debug_mode THEN
            write_log(p_module_name, p_unit_name, '[VAR] '
                                                  || p_name
                                                  || ' = '
                                                  || p_value, p_line_no, p_log_level);

        END IF;
    END;

  -- Log de erori
    PROCEDURE log_error (
        p_module_name VARCHAR2,
        p_unit_name   VARCHAR2,
        p_err         VARCHAR2,
        p_line_no     PLS_INTEGER,
        p_log_level   VARCHAR2
    ) IS
    BEGIN
    -- întotdeauna logăm erorile, chiar dacă debug_mode = FALSE
        write_log(p_module_name, p_unit_name, p_err, p_line_no, p_log_level);
    END;

END debug_utils;
/

-- Am creat un alt package pentru a testa dacă se afișează și alte denumiri de package decat cea în care se află procedura de inserare - write_log
CREATE OR REPLACE PACKAGE hr_management AS
    PROCEDURE adjust_salaries_by_commission;

    FUNCTION test_error_logging RETURN NUMBER;

END hr_management;
/

CREATE OR REPLACE PACKAGE BODY hr_management IS

    PROCEDURE adjust_salaries_by_commission IS
      -- Cursor explicit pentru toți angajații
        CURSOR cur_emp IS
        SELECT
            employee_id,
            salary,
            commission_pct
        FROM
            employees2;

        v_new_salary employees2.salary%TYPE;
        v_unit_name  VARCHAR2(200);
    BEGIN
        -- Obține, sub forma "PACHET.SUBPROGRAM", numele complet calificat al subprogramului curent
        v_unit_name := utl_call_stack.concatenate_subprogram(utl_call_stack.subprogram(1));

        debug_utils.log_msg($$plsql_unit,
                            v_unit_name,
                            '>>> START ' || $$plsql_unit,
                            $$plsql_line,
                            debug_utils.g_log_levels(2));
    
      -- Iterăm fiecare angajat
        FOR r IN cur_emp LOOP
        -- Logăm datele inițiale
            debug_utils.log_variable($$plsql_unit,
                                     v_unit_name,
                                     'EMP_ID',
                                     r.employee_id,
                                     $$plsql_line,
                                     debug_utils.g_log_levels(1));

            debug_utils.log_variable($$plsql_unit,
                                     v_unit_name,
                                     'OLD_SALARY',
                                     r.salary,
                                     $$plsql_line,
                                     debug_utils.g_log_levels(1));
    
           -- Calculăm noul salariu
            IF r.commission_pct IS NOT NULL THEN
                v_new_salary := r.salary * ( 1 + r.commission_pct );
                debug_utils.log_msg($$plsql_unit,
                                    v_unit_name,
                                    'Commission_pct found: ' || to_char(r.commission_pct),
                                    $$plsql_line,
                                    debug_utils.g_log_levels(1));

            ELSE
                v_new_salary := r.salary * 1.02;
                debug_utils.log_msg($$plsql_unit,
                                    v_unit_name,
                                    'Commission_pct NULL, applied default 2%',
                                    $$plsql_line,
                                    debug_utils.g_log_levels(3));

            END IF;
    
            -- Actualizăm în tabel
            UPDATE employees2
            SET
                salary = v_new_salary
            WHERE
                employee_id = r.employee_id;

            debug_utils.log_msg($$plsql_unit,
                                v_unit_name,
                                'Updated SALARY -> ' || to_char(v_new_salary),
                                $$plsql_line,
                                debug_utils.g_log_levels(1));
        END LOOP;
    
        COMMIT;
        debug_utils.log_msg($$plsql_unit,
                            v_unit_name,
                            '<<< END ' || $$plsql_unit,
                            $$plsql_line,
                            debug_utils.g_log_levels(2));

    EXCEPTION
        WHEN OTHERS THEN
            debug_utils.log_error($$plsql_unit,
                                  v_unit_name,
                                  'Code =['
                                  || sqlcode
                                  || '] > '
                                  || sqlerrm,
                                  $$plsql_line,
                                  debug_utils.g_log_levels(4));

            ROLLBACK;
            RAISE;
    END adjust_salaries_by_commission;

    FUNCTION test_error_logging RETURN NUMBER IS
        v_unit_name VARCHAR2(200);
        v           NUMBER;
    BEGIN
        -- obținem numele complet (pachet + subprogram)
        v_unit_name := utl_call_stack.concatenate_subprogram(utl_call_stack.subprogram(1));

        -- provoacă eroarea de tip zero-division
        v := 1 / 0;

        -- dacă n-ar fi aruncată excepția, am returna rezultatul
        RETURN v;
    EXCEPTION
        WHEN OTHERS THEN
            -- logăm întotdeauna eroarea, indiferent de modul debug
            debug_utils.log_error($$plsql_unit,                       -- numele pachetului
                                  v_unit_name,                        -- numele funcției
                                  'Code = ['
                                  || sqlcode
                                  || '] > '    -- mesaj compus
                                  || sqlerrm,
                                  $$plsql_line,                       -- linia PL/SQL
                                  debug_utils.g_log_levels(4)        -- nivel ERROR
                                  );

            -- returnăm NULL pentru a semnala că a apărut o eroare
            RETURN NULL;
    END test_error_logging;

END hr_management;
/

CREATE OR REPLACE PROCEDURE adjust_salaries_by_commission IS
      -- Cursor explicit pentru toți angajații
    CURSOR cur_emp IS
    SELECT
        employee_id,
        salary,
        commission_pct
    FROM
        employees2;

    v_new_salary employees2.salary%TYPE;
    v_unit_name  VARCHAR2(200);
BEGIN
    v_unit_name := utl_call_stack.concatenate_subprogram(utl_call_stack.subprogram(1));
    debug_utils.log_msg($$plsql_unit,
                        v_unit_name,
                        '>>> START STORED PROCEDURE ' || $$plsql_unit,
                        $$plsql_line,
                        debug_utils.g_log_levels(2));
    
      -- Iterăm fiecare angajat
    FOR r IN cur_emp LOOP
        -- Logăm datele inițiale
        debug_utils.log_variable($$plsql_unit,
                                 v_unit_name,
                                 'EMP_ID',
                                 r.employee_id,
                                 $$plsql_line,
                                 debug_utils.g_log_levels(1));

        debug_utils.log_variable($$plsql_unit,
                                 v_unit_name,
                                 'OLD_SALARY',
                                 r.salary,
                                 $$plsql_line,
                                 debug_utils.g_log_levels(1));
    
        -- Calculăm noul salariu
        IF r.commission_pct IS NOT NULL THEN
            v_new_salary := r.salary * ( 1 + r.commission_pct );
            debug_utils.log_msg($$plsql_unit,
                                v_unit_name,
                                'Commission_pct found: ' || to_char(r.commission_pct),
                                $$plsql_line,
                                debug_utils.g_log_levels(1));

        ELSE
            v_new_salary := r.salary * 1.02;
            debug_utils.log_msg($$plsql_unit,
                                v_unit_name,
                                'Commission_pct NULL, applied default 2%',
                                $$plsql_line,
                                debug_utils.g_log_levels(3));

        END IF;
    
        -- Actualizăm în tabel
        UPDATE employees2
        SET
            salary = v_new_salary
        WHERE
            employee_id = r.employee_id;

        debug_utils.log_msg($$plsql_unit,
                            v_unit_name,
                            'Updated SALARY -> ' || to_char(v_new_salary),
                            $$plsql_line,
                            debug_utils.g_log_levels(1));
    END LOOP;
    
    COMMIT;
    debug_utils.log_msg($$plsql_unit,
                        v_unit_name,
                        '<<< END STORED PROCEDURE ' || $$plsql_unit,
                        $$plsql_line,
                        debug_utils.g_log_levels(2));

EXCEPTION
    WHEN OTHERS THEN
        debug_utils.log_error($$plsql_unit,
                              v_unit_name,
                              'Code =['
                              || sqlcode
                              || '] > '
                              || sqlerrm,
                              $$plsql_line,
                              debug_utils.g_log_levels(4));

        ROLLBACK;
        RAISE;
END adjust_salaries_by_commission;
/





DELETE FROM debug_log;

BEGIN
    debug_utils.enable_debug;
  --debug_utils.disable_debug;
END;
/

-- provoacă eroare pentru a testa functionalitatea

BEGIN
    DECLARE
        v_unit_name VARCHAR2(200);
        v           NUMBER;
    BEGIN
        v_unit_name := utl_call_stack.concatenate_subprogram(utl_call_stack.subprogram(1));
        v := 1 / 0;
    EXCEPTION
        WHEN OTHERS THEN
            debug_utils.log_error($$plsql_unit,
                                  v_unit_name,
                                  'Code = ['
                                  || sqlcode
                                  || '] > '
                                  || sqlerrm,
                                  $$plsql_line,
                                  debug_utils.g_log_levels(4));
    --RAISE;
    END;
END;
/

DECLARE
    result NUMBER;
BEGIN
    result := hr_management.test_error_logging;
END;
/

BEGIN
    hr_management.adjust_salaries_by_commission;
END;
/


-- Exista si procedura stocata cu numele adjust_salaries_by_commission care are acelasi cod ca cea din package-ul hr_management.
-- A fost creata cu scopul de a evidentia o scriere diferita in tabelul debug_log in coloana MODULE_NAME
BEGIN
    adjust_salaries_by_commission;
END;
/

SELECT
    *
FROM
    debug_log
ORDER BY log_time;

--ROLLBACK; -- rollback to default on table employees2 [ optional ]

